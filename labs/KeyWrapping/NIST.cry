module labs::KeyWrapping::NIST where

import specs::Primitive::Symmetric::Cipher::Block::AES as AES
import specs::Primitive::Symmetric::Cipher::Block::TripleDES as TDES

type BlockSize = 128
type SemiBlockSize = BlockSize / 2
type Block = [BlockSize]
type SemiBlock = [SemiBlockSize]
type KEKSize = 128



//
//
//
// type my_n = 3 // hand-coded for now

W : [KEKSize] -> [3 * SemiBlockSize] -> [3 * SemiBlockSize] // ?? output type...
W KEK S = Cs
  where
    CIPH_K P = AES::aesEncrypt (KEK, P)
  
    Ss = split`{3} S
    A0 = Ss@0
    Rs = drop`{1} Ss

    States = [(A0, Rs)] # [ WStep t state | state <- States | t:[64] <- [1..12] ]
    C1  = (last States).0
    Cis = (last States).1
    Cs = C1 # (join Cis)
    
    WStep : [64] -> (SemiBlock, [2]SemiBlock) -> (SemiBlock, [2]SemiBlock)
    WStep t (A, Ris) = (A', Ris')
      where
        tmp    = CIPH_K ( A # (last Ris) )
        MSB_64 = take`{64} tmp
        LSB_64 = drop`{64} tmp
        A'     = t ^ MSB_64
        Ris'   = (drop`{1} Ris) # [LSB_64]

KW : [KEKSize] -> [2*SemiBlockSize] -> [3*SemiBlockSize]
KW KEK P = C
  where
    ICV1 = 0xA6A6A6A6A6A6A6A6
    S = ICV1 # P
    C = W KEK S
  

// 6.1 W and Winv
// input: string of n semiblocks, for some n >= 3
// output: C1 || C2 || ... || Cn

//W : {n} (fin n, n >= 3) => [n]SemiBlock -> [n]SemiBlock
//W S = join Cs
//  where
//    s = 6 * (`(n) - 1)
//    Ss = split`{n} S
//    A_0 = Ss@0
//    Cs = split`{n} S
//    R_0s = drop`{1} Ss
    
    
// 1.
//  let s = 6 (n - 1)
//  Let S 1 , S 2 , ... , S n be the semiblocks such that S=S 1 || S 2 ||... || S n .
//  Let A 0 = S 1 .
//  For i = 2, ..., n: let R i 0 = S i .

//2. Calculate the intermediate values. For t = 1, ..., s, update the variables as follows:
// a) A t = MSB 64 (CIPH K (A t-1 || R 2 t-1 )) âŠ• [t] 64 ;
//  b) For i = 2, ..., n-1: R it = R i+1 t-1 ;
//  c) R nt = LSB 64 (CIPH K (A t-1 || R 2 t-1 )).

// 3. Output the results:
//  a) Let C 1 = A s .
//  b) For i = 2, ..., n: C i = R is .
//  c) Return C 1 || C 2 || ... || C n .



// 6.2 KW
//KW : {n} (fin n, n >= 2) => [n]SemiBlock -> [n]SemiBlock
//KW P = W`{n+1} [ICV1] # P
//  where
//    ICV1 = 0xA6A6A6A6A6A6A6A6


//Algorithm 3 specifies the authenticated-encryption function for KW for a given block cipher and
//KEK. The wrapping function, W, specified in Algorithm 1 above, is invoked in Step 3 with the
//same block cipher and KEK as prerequisites.
//Algorithm 3: KW-AE(P)
//Prerequisites:
//KEK, K, for an approved, 128-bit block cipher;
//designated cipher function, CIPH K ;
//definition of valid plaintext lengths.
//Input:
//plaintext P, with valid length.
//Output:
//ciphertext C.
//Steps:
//1. Let ICV1 = 0xA6A6A6A6A6A6A6A6.
//2. Let S = ICV1 || P.
//3. Return C = W(S).
//
